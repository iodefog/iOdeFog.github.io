<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="iodefog"><title>页面置灰 · iodefog</title><meta name="description" content="背景一般在清明节、全国哀悼日、大地震的日子，以及一些影响力很大的伟人逝世或纪念日的时候，很多网站和App都会让自己的网站的全部网页变成灰色（黑白色），以表示我们对逝者的悼念。
那么今天就说说，通过几行简单的代码，来实现这个功能。
实现方案一、Web端置灰第一种：修改CSS文件我们可以在网页的CSS文"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/./images/logo.png" style="width:127px;"><h3 title=""><a href="/">iodefog</a></h3><div class="description"><p>记录人生道路景色的，点点滴滴。</p></div></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me" target="_blank" rel="noopener"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole" target="_blank" rel="noopener"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li><li><a href="/links">链接</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>页面置灰</a></h3></div><div class="post-content"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一般在清明节、全国哀悼日、大地震的日子，以及一些影响力很大的伟人逝世或纪念日的时候，很多网站和App都会让自己的网站的全部网页变成灰色（黑白色），以表示我们对逝者的悼念。</p>
<p>那么今天就说说，通过几行简单的代码，来实现这个功能。</p>
<h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><h2 id="一、Web端置灰"><a href="#一、Web端置灰" class="headerlink" title="一、Web端置灰"></a>一、Web端置灰</h2><p>第一种：修改CSS文件<br>我们可以在网页的CSS文件中添加以下的CSS代码，来实现网页黑白色，也就是网站变灰</p>
<p>CSS代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">    filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);</span><br><span class="line">    -webkit-filter: grayscale(100%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：在网页的<head>标签内加入以下代码<br>如果你不想改动CSS文件，你可以通过在网页头部中的<head>标签内部加入内联CSS代码的形式实现网站网页变灰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">html &#123;</span><br><span class="line">filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale&#x3D;1);</span><br><span class="line">-webkit-filter: grayscale(100%);&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p>第三种：修改<html>标签加入内联样式<br>如里上面的两种方式都不喜欢，可以通过修改<html>标签，以加入内联样式的方法，达到网页变灰的效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;html style&#x3D;&quot;filter: progid:DXImageTransform.Microsoft.BasicImage(grayscale&#x3D;1);</span><br><span class="line">-webkit-filter: grayscale(100%);&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>第四种：作者本人用的CSS代码</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">body *&#123;</span><br><span class="line">-webkit-filter: grayscale(100%); /* webkit */</span><br><span class="line">-moz-filter: grayscale(100%); /*firefox*/</span><br><span class="line">-ms-filter: grayscale(100%); /*ie9*/</span><br><span class="line">-o-filter: grayscale(100%); /*opera*/</span><br><span class="line">filter: grayscale(100%);</span><br><span class="line">filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); </span><br><span class="line">filter:gray; /*ie9- */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS：以上几种方法，都是通过CSS的滤镜来控制页面的显示而已，唯一不同的就CSS代码调用的方式。各位，喜欢哪种就自己挖去吧！</p>
<p>参考：<a href="https://www.feiniaomy.com/post/243.html" target="_blank" rel="noopener">https://www.feiniaomy.com/post/243.html</a></p>
<h2 id="二、iOS端置灰"><a href="#二、iOS端置灰" class="headerlink" title="二、iOS端置灰"></a>二、iOS端置灰</h2><h3 id="方法一：分别将图片和文字置灰"><a href="#方法一：分别将图片和文字置灰" class="headerlink" title="方法一：分别将图片和文字置灰"></a>方法一：分别将图片和文字置灰</h3><p>一般情况下，App页面的颜色深度是24bit，也就是RGB各8bit；如果算上Alpha通道的话就是32bit，RGBA(或者ARGB)各8bit。灰度图像的颜色深度是8bit，这8bit表示的颜色不是彩色，而是256种不同亮度的黑色或白色。<br>说到灰度图像，在YUV颜色空间上—其中Y代表亮度，调整Y值就可以得到不同的灰度图像。</p>
<p>理论上，颜色空间RGB和YUV是等价的，同一种颜色用RGB或YUV都可以表示。从RGB数值对应到亮度Y，一般采用公式Y <strong>= 0.299R+0.587G+0.114B</strong>，得到的结果再填充到RGB上就得到了对应的灰度RGB颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y &#x3D; 0.299R+0.587G+0.114B</span><br><span class="line">Gray &#x3D; RGB(Y,Y,Y)</span><br></pre></td></tr></table></figure>

<p>以上是方法一App页面置灰的原理基础。</p>
<p>UIImage转成灰度图<br>核心是创建一个灰度空间，然后将图像绘制到这个空间上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">－(UIImage*)getGrayImage:(UIImage*)sourceImage </span><br><span class="line">&#123; </span><br><span class="line">   int width &#x3D; sourceImage.size.width; </span><br><span class="line">   int height &#x3D; sourceImage.size.height; </span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 创建灰度空间</span><br><span class="line">   CGColorSpaceRef colorSpace &#x3D;CGColorSpaceCreateDeviceGray(); </span><br><span class="line">   &#x2F;&#x2F; 创建绘制上下文</span><br><span class="line">   CGContextRef context &#x3D;CGBitmapContextCreate(nil,width,height,8,0,colorSpace,kCGImageAlphaNone); </span><br><span class="line">   CGColorSpaceRelease(colorSpace); </span><br><span class="line"></span><br><span class="line">   if(context&#x3D;&#x3D; NULL)&#123; </span><br><span class="line">       return nil; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F; 绘制原始图像到新的上下文（灰度）</span><br><span class="line">   CGContextDrawImage(context,CGRectMake(0,0, width, height), sourceImage.CGImage); </span><br><span class="line">   &#x2F;&#x2F; 获取灰度图像</span><br><span class="line">   CGImageRef grayImageRef &#x3D;CGBitmapContextCreateImage(context);</span><br><span class="line">   &#x2F;&#x2F; CGImage -&gt; UIImage</span><br><span class="line">   UIImage*grayImage&#x3D;[UIImage imageWithCGImage:grayImageRef];</span><br><span class="line">   &#x2F;&#x2F;回收资源</span><br><span class="line">   CGContextRelease(context);</span><br><span class="line">   CGImageRelease(grayImageRef);</span><br><span class="line"></span><br><span class="line">   return grayImage; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UIColor转成灰度颜色</p>
<p>比较简单了，使用公式就可以了*<em>Y = 0.299R+0.587G+0.114B<br>*</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIColor *color &#x3D; xxxx;</span><br><span class="line">CGFloat r,g,b,a;</span><br><span class="line">[color getRed:&amp;r green:&amp;g&gt; blue:&amp;b alpha:&amp;a];</span><br><span class="line">CGFloat y &#x3D; 0.299*r+0.587*g+0.114*b;</span><br><span class="line">UIColor *gray &#x3D; [UIColor colorWithRed:y green:y blue:y alpha:a]</span><br></pre></td></tr></table></figure>

<p>以上方案开始执行，结果：卡，一个字，卡。毕竟涉及到大量的主线程图片重新生成，cpu/内存抖动，特别是列表上，性能消耗太厉害了。观察实际图片使用情况：本地资源大量重复使用，远端大图列表中复用。两大性能消耗点，因此明显都可以通过缓存解决。</p>
<h3 id="方法二：给App整体添加灰色滤镜"><a href="#方法二：给App整体添加灰色滤镜" class="headerlink" title="方法二：给App整体添加灰色滤镜"></a>方法二：给App整体添加灰色滤镜</h3><p>这个方法可以是App整体置灰，包括WebView页面。<br>原理就是把App页面当成一副图像，使用另一副偏灰图像和这个图像进行叠加运算，从而得到新的图像。<br>iOS 提供了Core Image 滤镜，这些滤镜可以设置在UIView.layer上。<br>我们要做的就是选取合适的滤镜，并将滤镜放置到App的最顶层</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 最顶层视图，承载滤镜，自身不接收、不拦截任何触摸事件</span><br><span class="line">@interface UIViewOverLay : UIView</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation UIViewOverLay</span><br><span class="line">-(UIView*)hitTest:(CGPoint)point withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">UIWindow *window &#x3D; App的Window;</span><br><span class="line">UIViewOverLay *overlay &#x3D; [[UIViewOverLay alloc]initWithFrame:self.window.bounds];</span><br><span class="line">overlay.translatesAutoresizingMaskIntoConstraints &#x3D; false;</span><br><span class="line">overlay.backgroundColor &#x3D; [UIColor lightGrayColor];</span><br><span class="line">overlay.layer.compositingFilter &#x3D; @&quot;saturationBlendMode&quot;;</span><br><span class="line">[window addSubview:overlay];</span><br></pre></td></tr></table></figure>

<p>最后通过各种方法，要保证overlay在最顶层.COPY<br>上面使用的是UIView承载滤镜，其实看代码就知道了也可以直接使用CALayer来承载滤镜（需要注意的是在UIWindow上直接添加CALayer时，在某些特殊的场景可能会造成绘制异常）</p>
<h3 id="方法三-给App整体添加灰色滤镜（私有API）"><a href="#方法三-给App整体添加灰色滤镜（私有API）" class="headerlink" title="方法三: 给App整体添加灰色滤镜（私有API）"></a>方法三: 给App整体添加灰色滤镜（私有API）</h3><p>灵感来自UIVisualEffectView这个公开的API。既然这个类能够实现App任意页面的毛玻璃效果–一个基于高斯模糊的滤镜，那么必然可以仿照这个类实现其他滤镜效果。于是找到了CAFilter这个私有API，示意代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取RGBA颜色数值</span><br><span class="line">CGFloat r,g,b,a;</span><br><span class="line">[[UIColor lightGrayColor] getRed:&amp;r green:&amp;g blue:&amp;b alpha:&amp;a];</span><br><span class="line">&#x2F;&#x2F;创建滤镜</span><br><span class="line">id cls &#x3D; NSClassFromString(@&quot;CAFilter&quot;);</span><br><span class="line">id filter &#x3D; [cls filterWithName:@&quot;colorMonochrome&quot;];</span><br><span class="line">&#x2F;&#x2F;设置滤镜参数</span><br><span class="line">[filter setValue:@[@(r),@(g),@(b),@(a)] forKey:@&quot;inputColor&quot;];</span><br><span class="line">[filter setValue:@(0) forKey:@&quot;inputBias&quot;];</span><br><span class="line">[filter setValue:@(1) forKey:@&quot;inputAmount&quot;];</span><br><span class="line">&#x2F;&#x2F;设置给window</span><br><span class="line">window.layer.filters &#x3D; [NSArray arrayWithObject:filter];</span><br></pre></td></tr></table></figure>

<p>几个关键点：</p>
<ul>
<li><p>compositingFilter作用与layer背景，而blendmode本身作用于图层与其下方的内容。因此实际方案是在vc或者window上放置一个overlay view，只设置background去完成遮罩置灰。</p>
</li>
<li><p>别忘了userInteractionEnabled去完成overlay view的事件穿透。</p>
</li>
<li><p>调整backgroundColor与compositingFilter完成灰度计算逻辑，可以多试试寻找最佳效果。</p>
</li>
<li><p>这个方案会导致整体离屏渲染，注意性能。</p>
</li>
</ul>
<p>参考：</p>
<ol>
<li><a href="https://lrdcq.com/me/read.php/105.htm" target="_blank" rel="noopener">https://lrdcq.com/me/read.php/105.htm</a></li>
<li><a href="https://blog.z6z8.cn/2021/12/14/ios-app%E9%A1%B5%E9%9D%A2%E7%BD%AE%E7%81%B0%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">https://blog.z6z8.cn/2021/12/14/ios-app页面置灰实现</a></li>
</ol>
<h2 id="三、Android端置灰"><a href="#三、Android端置灰" class="headerlink" title="三、Android端置灰"></a>三、Android端置灰</h2><h3 id="方案1-Android页面绘制流程一般分为measure、layout、draw，页面置灰在draw方法中实现。"><a href="#方案1-Android页面绘制流程一般分为measure、layout、draw，页面置灰在draw方法中实现。" class="headerlink" title="方案1.Android页面绘制流程一般分为measure、layout、draw，页面置灰在draw方法中实现。"></a>方案1.Android页面绘制流程一般分为measure、layout、draw，页面置灰在draw方法中实现。</h3><p>draw方法参数有canvas、paint，canvas是界面的画布，paint是绘制界面的画笔。可以通过更改paint的属性更改界面背景颜色，通过设置颜色过滤器更改画笔的色调、饱和度和亮度。置灰效果饱和度为0，画笔的设置代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Paint  paint &#x3D; new  Paint();</span><br><span class="line">ColorMatrix cm &#x3D; new  ColorMatrix();</span><br><span class="line">cm.setStaturation(0);</span><br><span class="line">paint.setColorFilter(new ColorMatrixColorFilter(cm));</span><br></pre></td></tr></table></figure>

<h3 id="方案2-考虑性能使用HardwareLayer-GPU内部的Buffer-对绘制的图形进行缓存。设置方法setLayerType-强制View创建自己对应的层，并将自己绘制到层上。"><a href="#方案2-考虑性能使用HardwareLayer-GPU内部的Buffer-对绘制的图形进行缓存。设置方法setLayerType-强制View创建自己对应的层，并将自己绘制到层上。" class="headerlink" title="方案2.考虑性能使用HardwareLayer(GPU内部的Buffer)对绘制的图形进行缓存。设置方法setLayerType()强制View创建自己对应的层，并将自己绘制到层上。"></a>方案2.考虑性能使用HardwareLayer(GPU内部的Buffer)对绘制的图形进行缓存。设置方法setLayerType()强制View创建自己对应的层，并将自己绘制到层上。</h3><h3 id="方案3-给Activity的顶层View设置置灰，实现全局置灰效果。获取界面的根View："><a href="#方案3-给Activity的顶层View设置置灰，实现全局置灰效果。获取界面的根View：" class="headerlink" title="方案3.给Activity的顶层View设置置灰，实现全局置灰效果。获取界面的根View："></a>方案3.给Activity的顶层View设置置灰，实现全局置灰效果。获取界面的根View：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;java</span><br><span class="line">View view  &#x3D; activity. getWindow(). getDecorView();</span><br><span class="line"> Paint paint &#x3D; new  Paint();</span><br><span class="line">ColorMatrix cm &#x3D; new  ColorMatrix();</span><br><span class="line">cm.setStaturation(0);</span><br><span class="line">paint.setColorFilter(new ColorMatrixColorFilter(cm));</span><br><span class="line">view. setLayerType(View.LAYER_TYPE_HARDWARE, paint);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;kotlin</span><br><span class="line">val view: View &#x3D; window.decorView</span><br><span class="line">val paint &#x3D; Paint()</span><br><span class="line">val cm &#x3D; ColorMatrix()</span><br><span class="line">cm.setSaturation(0f)</span><br><span class="line">paint.colorFilter &#x3D; ColorMatrixColorFilter(cm)</span><br><span class="line">view.setLayerType(View.LAYER_TYPE_HARDWARE, paint)</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.jianshu.com/p/340951afeb78" target="_blank" rel="noopener">https://www.jianshu.com/p/340951afeb78</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-12-02</span><i class="fa fa-tag"></i></div></div></div></div><div class="pagination"><ul class="clearfix"></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>